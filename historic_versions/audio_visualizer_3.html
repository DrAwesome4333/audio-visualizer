<!DOCTYPE html>
<html>
<head>
	<title>Audio Visualizer 3.0</title>
	<link rel="icon" 
      type="image/x-icon" 
	  href="https://drawesome4333.github.io/favicon.ico">
	  <style>
		  :root{
			  --true-height:100vh;
		  }
		Body{
			background-color:#fff;
			color:white;
		}
	  .playlistItem{
		cursor:pointer;
		border-bottom:1pt black solid;
		transition:all 0.5s ease-in-out;
		position:relative;
		top:0px;
		height:150px;
		width:34vw;
		overflow:hidden;
		background-image: linear-gradient(to right, rgba(0,0,0,1) , rgba(0,0,0,0));
		direction:ltr;
	  }
	  
	  .songTitle{
		  font-size:20pt;
		  font-family:Verdana, Geneva, Tahoma, sans-serif;
	  }
	  .songCover{
		  float:left;
		  margin:5px;
	  }
	  .playlistItem:hover{
		  /*background-color:rgb(40, 40, 40);*/
		  background-image: linear-gradient(to right, rgba(40, 40, 40,1) , rgba(40, 40, 40,0.7), rgba(0,0,0,0));
		  height:160px;
	  }
	  .playlistItem:-moz-dragover{
		border-top:3pt solid blue;
	  }
	  .songInError:hover{
		/* background-color:rgb(240,140,140); */
		 background-image: linear-gradient(to right, rgba(240,140,140,1), rgba(240,140,140,0.7) , rgba(0,0,0,0));
	  }
	  .songInError{
		/* background-color:rgb(170, 94, 94);  */
		 background-image: linear-gradient(to right, rgba(170, 94, 94,1), rgba(170, 94, 94,0.7) , rgba(0,0,0,0));
	  }
	  .songPlaying:hover{
		  /*background-color:rgb(140,140,240);  */
		  background-image: linear-gradient(to right, rgba(140,140,240,1), rgba(140,140,240,0.7), rgba(0,0,0,0));
	  }
	  .songPlaying{
		  /*background-color:rgb(94,94,170);  */
		  background-image: linear-gradient(to right, rgba(94,94,170,1), rgba(94,94,170,0.7) , rgba(0,0,0,0));
	  }
	  .songDisabled:hover{
		  /*background-color:rgb(140,140,140);  */
		  background-image: linear-gradient(to right, rgba(140,140,140,1), rgba(140,140,140,0.7) , rgba(0,0,0,0));
	  }
	  .songDisabled{
		  /*background-color:rgb(94,94,94); */
		  background-image: linear-gradient(to right, rgba(94,94,94,1), rgba(94,94,94,0.7) , rgba(0,0,0,0));
	  }
	  #Playlist{
		  width:34vw;
		  height:calc(var(--true-height)*0.75);
		  overflow-y:scroll;
		  position: relative;
		  top:0px;
		  left:0px;
		  direction:rtl;
	  }
	  #Player{
		width:34vw;
		height:calc(var(--true-height)*0.25);
		background-image: linear-gradient(to right, rgba(0,0,0,1) , rgba(0,0,0,0));
		
		border-bottom:2pt black solid;
	  }
	  #SidePanel{
		position:fixed;
		top:0px;
		left:0px;
		height:100%;
		width:134vw;
		background-image: linear-gradient(to right, rgba(0,0,0,1)  , rgba(0,0,0,0), rgba(0,0,0,0), rgba(0,0,0,0));
		  
		
		transition:all 0.5s ease-in-out;
		  
	  }
	  #SidePanel.hideToLeft{
		  left:-34vw !important;
	  }
	  #SidePanelArrow.hideToLeft{
		  width:100vw;
		  
	  }
	  #SidePanelArrow.hideToLeft:after{
		content: '\25B6' !important;
	  }
	  #SidePanelArrow:after{
		content: '\25C0';
	  }
	  #AddSongs{
		background-image: linear-gradient(to right, rgba(0,0,0,1) , rgba(0,0,0,0));
		height:90px;
		width:34vw;
		text-align:center;
		
		transition:all 0.5s ease-in-out;
		font-size:20pt;
		font-family:Verdana, Geneva, Tahoma, sans-serif;
		cursor: pointer;
		

	  }
	  #AddSongs:hover{
		  /*background-color:rgb(40, 40, 40);*/
		  background-image: linear-gradient(to right, rgba(50, 50, 50,1), rgba(0,0,0,0));
	  }
	  #SidePanelArrow{
		  width:100vw;
		  height:calc(var(--true-height));
		  float:right;
		  opacity:1;
		  background-image: linear-gradient(to left, rgba(0,0,0,0) 90%, rgba(0,0,0,1) 99%, rgba(0,0,0,0) 100%);
		transition:all 0.5s ease-in-out;
		font-size:30pt;
		vertical-align:middle;
		line-height:calc(var(--true-height));
	  }
	  canvas{
		  z-index:-1;
		  position:absolute;
		  top:0px;
		  left:0px;
		  width:100%;
		  height:100%;
	  }
	  #PlaceHolder{
		  border:none;
	  }
	  ::-webkit-scrollbar{
		  width:12px;
	  }
	  ::-webkit-scrollbar-thumb{
		  background-color:#444;
		  width:10px;
	  }
	  ::-webkit-scrollbar-thumb:hover{
		  background-color:#666;
	  }
	  ::-webkit-scrollbar-track{
		background-color:#222;
	  }
	  </style>
</head>
<body onload="document.documentElement.style.setProperty('--true-height',window.innerHeight+'px');" onresize = "document.documentElement.style.setProperty('--true-height',window.innerHeight+'px');if(Graphics.gl){Graphics.resize();};">
<div id="SidePanel">
	<div id="SidePanelArrow" onclick="this.parentElement.classList.toggle('hideToLeft');this.classList.toggle('hideToLeft')" onmousemove="ArrowTimer=3;this.style.opacity=1;"></div>
	<div id="Player">
		<audio id="audio" controls>
			<source id="src" type="audio/mp3">
			HTML5 Audio element is not supported on your browser.
		</audio>
		<br>
		<input type="button" value="Start Listening" onclick="start();requestMic();"><select id="input_select" onchange = "tryMic(parseInt(this.value));"></select>
	</div>
	<div id = "Playlist"><div id="AddSongs" onclick="var eve=new MouseEvent('click');start();fEle.dispatchEvent(eve);"><b>&#x2b</b><br>Add songs</div></div>



	<input type="file" id="files" accept="audio/*;" multiple style="display:none;">
	<p id="op"></p>
</div>
<canvas id="can" width = 1000 height = 300></canvas>
<script>
var aSrc=document.getElementById("src");
var aEle=document.getElementById("audio");
var fEle=document.getElementById("files");
var pEle = document.getElementById("Playlist");
var placeHolder=document.createElement("Div");
var specialEle=document.getElementById("AddSongs");//used as the "last playlist" item to allow drops into the final spot and allow shuffling
var iEle = document.getElementById("input_select");
var op=document.getElementById("op");
var hasStarted = false;
var audioDevices = [];
var ct = document.getElementById("can").getContext("2d");
var canvas = document.getElementById("can");
var arr;
var dataArray;
var movingSongId = -1;
var ArrowTimer = 3;
setInterval(function(){if(ArrowTimer>0){
	ArrowTimer--;
	if(ArrowTimer===0){
		document.getElementById("SidePanelArrow").style.opacity = "0";
	}
}},1000)
aEle.addEventListener("error",function(e){console.log("An error was triggered");console.log(e)});
aEle.addEventListener("progress",function(e){Player.songs[Player.songId].hasProgressed=true;});
aEle.addEventListener("stalled",function(e){console.log("A stalled event was triggered");console.log(e)});
aEle.addEventListener("ended",function(e){Player.nextSong();});
//specialEle.innerHTML="&#x2b<br>Add songs";
//specialEle.style.width="100%";
//specialEle.style.height = "5vh";
placeHolder.classList.add("playlistItem");
placeHolder.style.height="0px";
placeHolder.id="PlaceHolder";
//pEle.appendChild(specialEle);

specialEle.addEventListener("dragover",function(e){
		e.preventDefault();
	});
	specialEle.addEventListener("drop",function(e){
		e.preventDefault();
		var id = e.dataTransfer.getData("text");
		var movedEle = document.getElementById(id);
		pEle.insertBefore(movedEle,this);
		var movedId = parseInt(movedEle.id.substring(5,10),10);
		var oldIndex = -1;
		var newIndex = 0;
		if(movingSongId===-1){
			placeHolder.style.height="200px";
			pEle.insertBefore(placeHolder,movedEle);
			movedEle.style.height = "0px";
			setTimeout(function(){
				Player.songs[movingSongId].playlistItem.removeAttribute("style");
			//	console.log(movingSongId)
				placeHolder.style.height = "0px";
				movingSongId=-1;
			},1)
			
			movingSongId = movedId;
		}
		Player.songOrder.push(Player.songs[movedId]);
		for(;newIndex<Player.songOrder.length;newIndex++){
				//insert the song before the one that is reciving the drop
			
			if(Player.songOrder[newIndex].id==movedId){
				oldIndex = newIndex;
				break;
			}
		}
		if(oldIndex>=0){
			Player.songOrder.splice(oldIndex,1);//remove old song if it was found
		}
		if(Player.songId>=0){
			for(var i = 0;i<Player.songOrder.length;i++){//Update the song number as the list changed
			if(Player.songOrder[i].id===Player.songId){
				Player.songNumber = i;
				break;
			}
		}
		}
	})
function Cube(x,y,z,size,color,light){
this.x = x;
this.y = y;
this.z = z;
this.ox = 0;//orbit point
this.oy = 0;
this.oz = -650;
this.power = 0;
this.oldPower = 0;
this.dp = 0; //difference in power.
this.light = light;
this.tilt = (Math.random()-0.5)*60;
this.orbit = Math.random()*360;
this.tiltOffset =  Math.random()*360/180*Math.PI;//so all the cubes don't make an x
this.maxDistance = 3000;
this.minDistance = 100;
this.orbitDistance = 300;
this.musicSection = Math.floor(Math.random()*1024);
this.size = size;//the size of the model
this.scale = 1;//how the model is scaled
this.color = color;
this.bufferLength = 36;
this.rotation = [0,0,0];//in degs.
this.modelMat = Graphics.matrix.identity(4);
this.normalMat = Graphics.matrix.identity(3);
this.VBO = Graphics.gl.createBuffer();
this.IBO = Graphics.gl.createBuffer();
var lazyArray = [];
for(var i = 0;i<6;i++){
	lazyArray.push(i*4,i*4+1,i*4+2,i*4,i*4+3,i*4+1)//because I am too lazy to type a 36 element array.
}
Graphics.gl.bindBuffer(Graphics.gl.ELEMENT_ARRAY_BUFFER,this.IBO);
Graphics.gl.bufferData(Graphics.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(lazyArray),Graphics.gl.STATIC_DRAW);
//[x,y,x,r,g,b,nx,ny,nz,tx,ty]
this.buildVBO = function(){//used to update the VBO on a size or color (not scale) change
	var hs = this.size/2;//half size
	var c = this.color;
	var f = 1;
	if(this.light>-1){
		f = -1;
	}
	var anotherArray = [ 
		-hs, hs, hs, c[0],c[1],c[2], 0, 0, 1*f, 0,0,//front
		 hs,-hs, hs, c[0],c[1],c[2], 0, 0, 1*f, 1,1,
		 hs, hs, hs, c[0],c[1],c[2], 0, 0, 1*f, 1,0,
		-hs,-hs, hs, c[0],c[1],c[2], 0, 0, 1*f, 0,1,
  
		-hs, hs,-hs, c[0],c[1],c[2],-1*f, 0, 0, 0,0,//left
		-hs,-hs, hs, c[0],c[1],c[2],-1*f, 0, 0, 1,1,
		-hs, hs, hs, c[0],c[1],c[2],-1*f, 0, 0, 1,0,
		-hs,-hs,-hs, c[0],c[1],c[2],-1*f, 0, 0, 0,1,
  
		 hs, hs, hs, c[0],c[1],c[2], 1*f, 0, 0, 0,0,//right
		 hs,-hs,-hs, c[0],c[1],c[2], 1*f, 0, 0, 1,1,
		 hs, hs,-hs, c[0],c[1],c[2], 1*f, 0, 0, 1,0,
		 hs,-hs, hs, c[0],c[1],c[2], 1*f, 0, 0, 0,1,
  
		-hs, hs,-hs, c[0],c[1],c[2], 0, 1*f, 0, 0,0,//top
		 hs, hs, hs, c[0],c[1],c[2], 0, 1*f, 0, 1,1,
		 hs, hs,-hs, c[0],c[1],c[2], 0, 1*f, 0, 1,0,
		-hs, hs, hs, c[0],c[1],c[2], 0, 1*f, 0, 0,1,
  
		-hs,-hs, hs, c[0],c[1],c[2], 0,-1*f, 0, 0,0,//bottom
		 hs,-hs,-hs, c[0],c[1],c[2], 0,-1*f, 0, 1,1,
		 hs,-hs, hs, c[0],c[1],c[2], 0,-1*f, 0, 1,0,
		-hs,-hs,-hs, c[0],c[1],c[2], 0,-1*f, 0, 0,1,
  
		 hs, hs,-hs, c[0],c[1],c[2], 0, 0,-1*f, 0,0,//back
		-hs,-hs,-hs, c[0],c[1],c[2], 0, 0,-1*f, 1,1,
		-hs, hs,-hs, c[0],c[1],c[2], 0, 0,-1*f, 1,0,
		 hs,-hs,-hs, c[0],c[1],c[2], 0, 0,-1*f, 0,1
	]
	Graphics.gl.bindBuffer(Graphics.gl.ARRAY_BUFFER,this.VBO);
	Graphics.gl.bufferData(Graphics.gl.ARRAY_BUFFER,new Float32Array(anotherArray),Graphics.gl.STATIC_DRAW);
}
this.update=function(){
	this.OldPower = this.power;
	if(this.OldPower!=0){
		this.dp = this.power/this.OldPower/1.5;
	}
	if(this.power<arr[this.musicSection]/255){
		this.power = arr[this.musicSection]/255;
	}else{
		if(this.power>0)
		this.power-=0.1;
		if(this.power<0){
			this.power = 0;
		}
	}
	
	this.scale = this.power*5;
	this.orbit += this.power * 0.5  *(this.maxDistance/this.orbitDistance);
	this.orbit %= 360;
	this.orbitDistance += (this.power*this.power-0.25)*10*(this.maxDistance/this.orbitDistance);
	this.rotation[0]+=this.power*2;
	this.rotation[1]+=this.power*2+0.1;
	if(this.orbitDistance>this.maxDistance){
		this.orbitDistance = this.maxDistance;
	}else if(this.orbitDistance<this.minDistance){
		this.orbitDistance = this.minDistance;
	}
	var orbit = this.orbit/180*Math.PI;
	var tilt = this.tilt/180*Math.PI;
	var oldX = 0;
	var oldY = 0;
	var oldZ = 0;
	this.x = this.orbitDistance*Math.cos(orbit);
	this.y = 0;
	this.z = this.orbitDistance*Math.sin(orbit);
	oldX = this.x;
	oldY = this.y;
	this.x = oldX*Math.cos(tilt) - oldY*Math.sin(tilt);
	this.y = oldX*Math.sin(tilt) + oldY*Math.cos(tilt)+this.oy;
	oldX = this.x;
	oldZ = this.z;
	this.x = oldX*Math.cos(this.tiltOffset) - oldZ*Math.sin(this.tiltOffset)+this.ox;
	this.z = oldX*Math.sin(this.tiltOffset) + oldZ*Math.cos(this.tiltOffset)+this.oz;
	this.buildModelMat();
	if(this.light>-1){
		Graphics.lightPos[this.light*3]=this.x;
		Graphics.lightPos[this.light*3+1]=this.y;
		Graphics.lightPos[this.light*3+2]=this.z;
		Graphics.lightColor[this.light*3]=this.color[2]*this.power+0.1;
		Graphics.lightColor[this.light*3+1]=this.color[2]*this.power+0.1;
		Graphics.lightColor[this.light*3+2]=this.color[2]*this.power+0.1;
	}
}
this.buildModelMat=function(){
var xr = this.rotation[0]*Math.PI/180;
var yr = this.rotation[1]*Math.PI/180;
var zr = this.rotation[2]*Math.PI/180;
var xm = [1,0,0,
		  0, Math.cos(xr),-Math.sin(xr),
		  0, Math.sin(xr),Math.cos(xr)];
var ym = [Math.cos(yr),0,Math.sin(yr),
		  0,1 ,0,
		  -Math.sin(yr), 0,Math.cos(yr)];
var zm = [Math.cos(zr), -Math.sin(zr) ,0,
          Math.sin(zr),Math.cos(zr) ,0,
		 0, 0,1];
this.normalMat = Graphics.matrix.mult3x3([this.scale,0,0,
										 0,this.scale,0,
										 0,0,this.scale],xm);
this.normalMat = Graphics.matrix.mult3x3(this.normalMat,ym);
this.normalMat = Graphics.matrix.mult3x3(this.normalMat,ym);
this.modelMat = Graphics.matrix.mult4x4([this.normalMat[0],this.normalMat[1],this.normalMat[2],0,
										 this.normalMat[3],this.normalMat[4],this.normalMat[5],0,
				 						 this.normalMat[6],this.normalMat[7],this.normalMat[8],0,
				 						 0,0,0,1],
										[1,0,0,0,
				 0,1,0,0,
				 0,0,1,0,
				 this.x,this.y,this.z,1])/*
this.modelMat = [1,0,0,0,
				 0,1,0,0,
				 0,0,1,0,
				 this.x,this.y,this.z,1];
this.normalMat = Graphics.matrix.identity(3);*/

};
this.buildVBO();
this.buildModelMat();
}
var Graphics = {
	canvas:document.createElement("CANVAS"),
	gl:null,
	canvas_settings:{
		width:0,
		height:0,
		top:0,
		left:0,
		p_width:0,
		p_height:0,//previous width/height, lets a function know if the view port needs to be updated
		fullScreen:false,//if true the canvas will attempt to take up the whole screen
		shouldShow:true
	},
	particles:{
		
	},
	lightPos:[0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0],
	lightColor:[0.25,0.25,0.25, 0.5,0.0,0.0, 0.0,0.5,0.0, 0.5,0.5,0.0, 0.0,0.0,0.5, 0.5,0.0,0.5, 0.0,0.5,0.5, 0.0,0.0,0.5],
	cubes:[],
	state:{
		mode:-1,//-2 is fatal error(IE no WebGL or Audioapi),-1 is not running, 0 is frequencyParticles, 1 is cubeField, 2 is cubeWaveForm
		particles:true//wether or not to do particles on modes that don't require it
	},
	camera:{
		height:0,
		target:{
			x:0,
			y:0,
			z:-650
		},
		matrix:null,
		angle:0,
		direction:1
	},
	textures:{
		plainWhite:null
	},
	shaderSources:{
		mainVertexShader:"\n\
		attribute vec3 pos;\n\
		attribute vec3 color;\n\
		attribute vec2 tex;\n\
		attribute vec3 normal;\n\
		varying vec3 f_pos;\n\
		varying vec3 f_color;\n\
		varying vec3 f_normal;\n\
		varying vec2 f_tex;\n\
		uniform mat4 world;\n\
		uniform mat4 model;\n\
		uniform mat4 perspective;\n\
		uniform mat3 normal_matrix;\n\
		void main(void){\n\
			f_color = color;\n\
			f_normal = normal_matrix*normal;\n\
			f_tex = tex;\n\
			f_pos = (world*model*vec4(pos,1.0)).xyz;\n\
			gl_Position=(perspective*world*model*vec4(pos,1.0));\n\
		}",
		mainFragmentShader:"\n\
		precision mediump float;\n\
		varying vec3 f_pos;\n\
		varying vec3 f_color;\n\
		varying vec3 f_normal;\n\
		varying vec2 f_tex;\n\
		uniform vec3 light_pos[8];\n\
		uniform vec3 light_color[8];\n\
		uniform sampler2D texture;\n\
		uniform vec3 fog_color;\n\
		uniform vec3 ambient_color;\n\
		void main(void){\n\
			\n\
			vec3 normal = normalize(f_normal);\n\
			vec3 total_light = vec3(0.0,0.0,0.0);\n\
			float light_strength = 0.0;\n\
			float spec_strength = 0.0;\n\
			vec3 surface_to_light = vec3(0.0,0.0,0.0);\n\
			vec3 surface_to_camera = normalize(-f_pos);\n\
			vec3 half_vector = vec3(0.0,0.0,0.0);\n\
			vec3 base = f_color * texture2D(texture,f_tex).rgb;\n\
			\n\
			for(int i = 0;i < 8;i++){\n\
				surface_to_light = normalize(light_pos[i]-f_pos);\n\
				light_strength = max(dot(normal,surface_to_light),0.0);\n\
				half_vector = normalize(surface_to_light+surface_to_camera);\n\
				spec_strength = pow(max(dot(half_vector,normal),0.0),100.0);\n\
				total_light+=base*(light_strength*light_color[i]);\n\
				total_light+=base*(spec_strength*light_color[i]);\n\
			}\n\
			total_light+=ambient_color*base;\n\
			float amount = smoothstep(900.0, 1000.0, gl_FragCoord.z);\n\
			gl_FragColor = vec4(mix(total_light,fog_color,amount),1.0);\n\
			\n\
		}"
	},
	uniforms:{
		main:{
			world:null,
			model:null,
			perspective:null,
			normal_matrix:null,
			light_pos:null,
			light_color:null,
			texture:null,
			fog_color:null,
			ambient_color:null

		}
	},
	attributes:{
		main:{
			pos:null,
			color:null,
			tex:null,
			normal:null
		}
	},
	programs:{
		main:null
	},
	shaders:{
		vertexShaders:{
			main:null
		},
		fragmentShaders:{
			main:null
		}
	},
	matrix:{
		mult4x4:function(matA,matB){
			return [
				matA[ 0]*matB[0]+matA[ 1]*matB[4]+matA[ 2]*matB[8]+matA[ 3]*matB[12], matA[ 0]*matB[1]+matA[ 1]*matB[5]+matA[ 2]*matB[9]+matA[ 3]*matB[13], matA[ 0]*matB[2]+matA[ 1]*matB[6]+matA[ 2]*matB[10]+matA[ 3]*matB[14], matA[ 0]*matB[3]+matA[ 1]*matB[7]+matA[ 2]*matB[11]+matA[ 3]*matB[15],
				matA[ 4]*matB[0]+matA[ 5]*matB[4]+matA[ 6]*matB[8]+matA[ 7]*matB[12], matA[ 4]*matB[1]+matA[ 5]*matB[5]+matA[ 6]*matB[9]+matA[ 7]*matB[13], matA[ 4]*matB[2]+matA[ 5]*matB[6]+matA[ 6]*matB[10]+matA[ 7]*matB[14], matA[ 4]*matB[3]+matA[ 5]*matB[7]+matA[ 6]*matB[11]+matA[ 7]*matB[15],
				matA[ 8]*matB[0]+matA[ 9]*matB[4]+matA[10]*matB[8]+matA[11]*matB[12], matA[ 8]*matB[1]+matA[ 9]*matB[5]+matA[10]*matB[9]+matA[11]*matB[13], matA[ 8]*matB[2]+matA[ 9]*matB[6]+matA[10]*matB[10]+matA[11]*matB[14], matA[ 8]*matB[3]+matA[ 9]*matB[7]+matA[10]*matB[11]+matA[11]*matB[15],
				matA[12]*matB[0]+matA[13]*matB[4]+matA[14]*matB[8]+matA[15]*matB[12], matA[12]*matB[1]+matA[13]*matB[5]+matA[14]*matB[9]+matA[15]*matB[13], matA[12]*matB[2]+matA[13]*matB[6]+matA[14]*matB[10]+matA[15]*matB[14], matA[12]*matB[3]+matA[13]*matB[7]+matA[14]*matB[11]+matA[15]*matB[15],
			];
		},
		mult3x3:function(matA,matB){
			return [
				matA[0]*matB[0]+matA[1]*matB[3]+matA[2]*matB[6], matA[0]*matB[1]+matA[1]*matB[4]+matA[2]*matB[7], matA[0]*matB[2]+matA[1]*matB[5]+matA[2]*matB[8],
				matA[3]*matB[0]+matA[4]*matB[3]+matA[5]*matB[6], matA[3]*matB[1]+matA[4]*matB[4]+matA[5]*matB[7], matA[3]*matB[2]+matA[4]*matB[5]+matA[5]*matB[8],
				matA[6]*matB[0]+matA[7]*matB[3]+matA[8]*matB[6], matA[6]*matB[1]+matA[7]*matB[4]+matA[8]*matB[7], matA[6]*matB[2]+matA[7]*matB[5]+matA[8]*matB[8]
			
			];
		},
		identity:function(size){
			switch(size){
				case 2:
					return [1,0,
					        0,1];
					break;
				case 3:
					return [1,0,0,
							0,1,0,
							0,0,1];
					break;
				case 4:
					return [1,0,0,0,
							0,1,0,0,
							0,0,1,0,
							0,0,0,1]
					break;
			}
		}
	},
	buildShader(shaderSource,type){
		var shader = this.gl.createShader(type);
		this.gl.shaderSource(shader,shaderSource);
		this.gl.compileShader(shader);
		console.log(this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS));
		console.log(this.gl.getShaderInfoLog(shader));
		return shader;
	},
	buildProgram(vertexShader,fragmentShader){
		var program = this.gl.createProgram();
		this.gl.attachShader(program,vertexShader);
		this.gl.attachShader(program,fragmentShader);
		this.gl.linkProgram(program);
		return program;
	},
	start:function() {
		if(this.mode>=0){
			return;
		}
		this.gl = this.canvas.getContext("webgl"||"experimental-webgl");
		if(this.gl==undefined || this.gl==null){
			this.mode = -2;
			console.log("Error: could not obtain WebGL context");
			alert("Faild to start visualizer!\nMake sure your web browser is up to date!")
			return;
		}
		this.canvas.style.zIndex="-2";
		this.canvas.style.width="100%";
		this.canvas.style.height="100%";
		this.canvas.style.top = "0px";
		this.canvas.style.left="0px";
		this.canvas.style.position = "absolute";
		document.body.appendChild(this.canvas);
		this.shaders.vertexShaders.main = this.buildShader(this.shaderSources.mainVertexShader,this.gl.VERTEX_SHADER);
		this.shaders.fragmentShaders.main = this.buildShader(this.shaderSources.mainFragmentShader,this.gl.FRAGMENT_SHADER);
		this.programs.main = this.buildProgram(this.shaders.vertexShaders.main,this.shaders.fragmentShaders.main);
		this.gl.useProgram(this.programs.main);
		this.attributes.main.pos = this.gl.getAttribLocation(this.programs.main,"pos");
		this.attributes.main.color = this.gl.getAttribLocation(this.programs.main,"color");
		this.attributes.main.normal = this.gl.getAttribLocation(this.programs.main,"normal");
		this.attributes.main.tex = this.gl.getAttribLocation(this.programs.main,"tex");

		this.uniforms.main.world = this.gl.getUniformLocation(this.programs.main,"world");
		this.uniforms.main.perspective = this.gl.getUniformLocation(this.programs.main,"perspective");
		this.uniforms.main.texture = this.gl.getUniformLocation(this.programs.main,"texture");
		this.uniforms.main.ambient_color = this.gl.getUniformLocation(this.programs.main,"ambient_color");
		this.uniforms.main.fog_color = this.gl.getUniformLocation(this.programs.main,"fog_color");
		this.uniforms.main.light_color = this.gl.getUniformLocation(this.programs.main,"light_color");
		this.uniforms.main.light_pos = this.gl.getUniformLocation(this.programs.main,"light_pos");
		this.uniforms.main.normal_matrix = this.gl.getUniformLocation(this.programs.main,"normal_matrix");
		this.uniforms.main.model = this.gl.getUniformLocation(this.programs.main,"model");

		this.gl.enableVertexAttribArray(this.attributes.main.pos);
		this.gl.enableVertexAttribArray(this.attributes.main.color);
		this.gl.enableVertexAttribArray(this.attributes.main.normal);
		this.gl.enableVertexAttribArray(this.attributes.main.tex);
		this.gl.activeTexture(this.gl.TEXTURE0);
		this.textures.plainWhite = this.gl.createTexture();
		this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.plainWhite);
 
		// Fill the texture with a 1x1 white pixel.
		this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE,  new Uint8Array([255, 255, 255, 255]));
		//no need to set up the uniform as it defaults to 0 and there is only one texture
		let r = -30*Math.PI/180;
  		this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.plainWhite);
		this.gl.uniformMatrix3fv(this.uniforms.main.normal_matrix,false,this.matrix.identity(3));
		this.gl.uniformMatrix4fv(this.uniforms.main.model,false,this.matrix.identity(4));
		this.gl.uniformMatrix4fv(this.uniforms.main.world,false,[1,0,0,0,
		  0, Math.cos(r),-Math.sin(r),0,
		  0, Math.sin(r),Math.cos(r),0,
		  0,0,0,1]);
		this.gl.uniformMatrix4fv(this.uniforms.main.perspective,false,this.matrix.identity(4));
		this.gl.uniform3fv(this.uniforms.main.ambient_color,[0.05,0.05,0.05]);
		this.gl.uniform3fv(this.uniforms.main.light_color,this.lightColor);
		this.gl.uniform3fv(this.uniforms.main.light_pos,this.lightPos)
		this.resize();
		this.gl.enable(this.gl.DEPTH_TEST);
		this.gl.depthFunc(this.gl.LEQUAL);
		this.gl.clearDepth(1.0);
		this.gl.enable(this.gl.CULL_FACE);
		this.gl.clearColor(0.0,0.0,0.0,1.0);
		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
		var chosenLights = [];
		var possibleList = [];
		var numberOfCubes = 1000;
		this.cubes=[];
		for(var i=0;i<numberOfCubes;i++){
			possibleList.push(i);
		}
		for(var i=0;i<8;i++){
			var random = Math.floor(Math.random()*possibleList.length);
			chosenLights.push(possibleList[random]);
			possibleList.splice(random,1);
		}
		for(var i = 0; i<numberOfCubes;i++){
			var x = Math.random()*150-75;
			var y = Math.random()*150-75;
			var z = -Math.random()*150-75;
			var l = -1;
			for(var j = 0;j<8;j++){
				if(chosenLights[j]==i){
					l = j;
				}
			}
			this.cubes.push(new Cube(x,y,z,Math.random()*5+5,[Math.random(),Math.random(),Math.random()],l));

		}

	},
	resize:function(){
		var newWidth = this.canvas.getBoundingClientRect().width;
		var newHeight= this.canvas.getBoundingClientRect().height;
		this.canvas.width = newWidth;
		this.canvas.height = newHeight;
		if(this.gl){
			this.gl.viewport(0,0,newWidth,newHeight);
			var f = Math.tan(Math.PI * 0.5 - 0.5 * 90*Math.PI/180);
			var rangeInv = 1.0 / (1 - 10000);
			var aspect = newWidth/newHeight;
			perspectiveMatrix = [
			f / aspect, 0, 0, 0,
			0, f, 0, 0,
			0, 0, (1 + 10000) * rangeInv, -1,
			0, 0, 1 * 10000 * rangeInv * 2, 0
			]
			this.gl.uniformMatrix4fv(this.uniforms.main.perspective,false,perspectiveMatrix);
		}
	},
	render:function(){
		var camera = this.camera;
		camera.angle += camera.direction;
		if(camera.angle>90){
			camera.direction = -0.1;
		}
		if(camera.angle<-90){
			camera.direction = 0.1;
		}
		camera.height = -Math.sin(camera.angle/180*Math.PI)*500;
		var r = Math.asin(camera.height/Math.sqrt(camera.height ** 2 + camera.target.z ** 2));
		var camMatrix = [1,0,0,0,
		  0, Math.cos(r),-Math.sin(r),0,
		  0, Math.sin(r),Math.cos(r),0,
		  0,0,0,1];
		camMatrix = this.matrix.mult4x4([1,0,0,0,
										    0,1,0,0,
											0,0,1,0,
											0,camera.height,0,1],camMatrix);
		this.gl.uniformMatrix4fv(this.uniforms.main.world,false, camMatrix);
		
		var totals = [0,0,0];
		for(var i = 0;i<this.lightColor.length;i+=3){
			totals[0]+=this.lightColor[i];
			totals[1]+=this.lightColor[i+1];
			totals[2]+=this.lightColor[i+2];
		}
		lAvg = [totals[0]/8,totals[1]/8,totals[2]/8]
		
		this.gl.clearColor(lAvg[0],lAvg[1],lAvg[2],1.0);
		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
		
		this.gl.uniform3fv(this.uniforms.main.light_color,this.lightColor);
		this.gl.uniform3fv(this.uniforms.main.light_pos,this.lightPos)
		for(var i = 0;i<this.cubes.length;i++){
			var cc = this.cubes[i];
			cc.update();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER,cc.VBO);
			this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,cc.IBO);
			//[x,y,x,r,g,b,nx,ny,nz,tx,ty]
			this.gl.uniformMatrix4fv(this.uniforms.main.model,false,cc.modelMat);
			this.gl.uniformMatrix3fv(this.uniforms.main.normal_matrix,false,cc.normalMat);

			this.gl.vertexAttribPointer(this.attributes.main.pos,3,this.gl.FLOAT,false,4*(11),0);
			this.gl.vertexAttribPointer(this.attributes.main.color,3,this.gl.FLOAT,false,4*(11),3*4);
			this.gl.vertexAttribPointer(this.attributes.main.normal,3,this.gl.FLOAT,false,4*(11),6*4);
			this.gl.vertexAttribPointer(this.attributes.main.tex,2,this.gl.FLOAT,false,4*(11),9*4);
			
			this.gl.drawElements(this.gl.TRIANGLES, cc.bufferLength , this.gl.UNSIGNED_SHORT, 0);
			
			//cc.buildModelMat();
		}//*/
		/*var aBuffer = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER,aBuffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([0.0,0.0,-100, 1.0,0.0,1.0, 0.0,0.0,-1.0, 0.0,0.0,
		500.0,500.0,-100, 1.0,1.0,0.0, 0.0,0.0,-1.0, 0.0,0.0,
		500.0,0.0,-100, 0.0,1.0,1.0, 0.0,0.0,-1.0, 0.0,0.0 ]),Graphics.gl.STATIC_DRAW);
		var anotherBuffer = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, anotherBuffer);
		this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2]),Graphics.gl.STATIC_DRAW)

		this.gl.vertexAttribPointer(this.attributes.main.pos,3,this.gl.FLOAT,false,4*(11),0);
		this.gl.vertexAttribPointer(this.attributes.main.color,3,this.gl.FLOAT,false,4*(11),3*4);
		this.gl.vertexAttribPointer(this.attributes.main.normal,3,this.gl.FLOAT,false,4*(11),6*4);
		this.gl.vertexAttribPointer(this.attributes.main.tex,2,this.gl.FLOAT,false,4*(11),9*4);
		
		this.gl.drawElements(this.gl.TRIANGLES, 3 , this.gl.UNSIGNED_SHORT, 0);
		//this.gl.flush();*/

	}
	

}
function Song(fileElement,fileNumber){
	this.length = 0;
	this.id = Player.songs.length;
	this.title = "Unknown";
	this.fileName = fileElement.files[fileNumber].name;
	this.artist = "Unkown Artist";
	this.album = "Unkown Album";
	this.composer = "";
	this.cover = new Image(100,100);//cover image file if one exists
	this.songTitleTag = document.createElement("div");
	this.flagged = false;//if true this song has an error that wont allow it to play
	this.format = "";
	this.hasProgressed = false;//helps catch songs that will not load
	this.fileElement = fileElement;//describes which file element holds this song's files
	this.fileNumber = fileNumber;
	this.URL = URL.createObjectURL(fileElement.files[fileNumber]);//used to store the URL created to pass song as a source to the audio player
	this.active = true;//so user can deactivate a song
	this.playlistItem = document.createElement("div");
	this.songTitleTag.innerHTML=this.fileName;
	this.playlistItem.classList.add("playlistItem");
	this.songTitleTag.classList.add("songTitle");
	this.cover.classList.add("songCover");
	this.isDisabled = function(){
		if(!this.active || this.flagged){
			return true;
		}
		return false;
	}
	this.play=function(){//returns true if successful
		start();//incase the code has not started yet
		
		if(Audio.mic.playing){
			Audio.mic.playing = false;
			Audio.mic.source.disconnect(Audio.analyser);
			Audio.state.source = 0;
		}

		if(this.isDisabled()){
			return false;
		}
		
		if(Player.songId>=0){
			Player.songs[Player.songId].playlistItem.classList.remove("songPlaying");
		}

		Player.songId=this.id;
		Audio.gainNode.gain.setValueAtTime(Player.volume,Audio.ctx.currentTime);
		aSrc.src = this.URL;
		aEle.load();
		aEle.play().then(function(){Player.songOrder[Player.songNumber].playlistItem.classList.add("songPlaying");}).catch(function(e){console.log(e)});
		setTimeout(function(){
			var song = Player.songs[Player.songId];
			if(!song.hasProgressed){
				song.flagged=true;
				song.active=false;
				song.checkBox.checked=false;
				song.checkBox.title="This song failed to load.";
				song.checkBox.style.cursor="not-allowed";
				song.playlistItem.classList.add("songInError");
				song.cover.src=Player.resources.errorCover.src;
				Player.nextSong();
			}
		},1000)
		//this.playlistItem.classList.add("songPlaying");
		for(var i = 0;i<Player.songOrder.length;i++){//find itself in the songOrder list to get the number so play can coninue from there if shuffeled
			if(Player.songOrder[i]===this){
				Player.songNumber = i;
				break;
			}
		}
		return true;
	}
	//this.playlistItem.style.cursor = "grab";
	this.playlistItem.addEventListener("click",function(){
		var songId = parseInt(this.id.substring(5,10),10);
		Player.songs[songId].play();
	});
	this.playlistItem.draggable=true;
	this.playlistItem.addEventListener("dragstart",function(e){
		e.dataTransfer.setData("text",e.target.id);
	});
	this.playlistItem.addEventListener("dragover",function(e){
		e.preventDefault();
	});
	this.playlistItem.addEventListener("drop",function(e){
		e.preventDefault();
		var id = e.dataTransfer.getData("text");
		var movedEle = document.getElementById(id);
		if(movingSongId===-1){
			placeHolder.style.height="160px";
			pEle.insertBefore(placeHolder,movedEle);
			movedEle.style.height = "0px";
			setTimeout(function(){
				Player.songs[movingSongId].playlistItem.removeAttribute("style");
			//	console.log(movingSongId)
				placeHolder.style.height = "0px";
				movingSongId=-1;
			},1)
		}
		pEle.insertBefore(movedEle,this);

		
		var songId = parseInt(this.id.substring(5,10),10);
		var movedId = parseInt(movedEle.id.substring(5,10),10);
		if(movingSongId===-1)
			movingSongId = movedId;
		var oldIndex = -1;
		var newIndex = 0;
		
		for(;newIndex<Player.songOrder.length;newIndex++){
			if(Player.songOrder[newIndex].id==songId){
				Player.songOrder.splice(newIndex,0,Player.songs[movedId]);//insert the song before the one that is reciving the drop
				newIndex++;
			}
			if(Player.songOrder[newIndex].id==movedId){
				oldIndex = newIndex;
			}
		}
		if(oldIndex>=0){
			Player.songOrder.splice(oldIndex,1);//remove old song if it was found
		}
		
		if(Player.songId>=0){
			for(var i = 0;i<Player.songOrder.length;i++){//Update the song number as the list changed
			if(Player.songOrder[i].id===Player.songId){
				Player.songNumber = i;
				break;
			}
		}
		}
	})
	var idString = (Player.songs.length).toString();
	while(idString.length<5){
		idString = "0"+idString;
	}
	this.playlistItem.id="song"+idString;
	this.checkBox = document.createElement("input");
	this.checkBox.type="checkbox";
	this.checkBox.style.cursor="pointer";
	this.checkBox.checked=true;
	this.checkBox.title="Disable Song";
	this.cover.src = Player.resources.defaultCover.src;
	this.checkBox.addEventListener("click",function(){
		var songId = parseInt(this.parentElement.id.substring(5,10),10);
		Player.songs[songId].active=this.checked;
		if(this.checked && !Player.songs[songId].isDisabled()){//checks if the song is Disabled for another reason before activating song.
			Player.songs[songId].playlistItem.classList.remove("songDisabled");
		}else if(this.checked){//if the last check failed but the check mark was checked, keep the song Disabled as it may be flagged.
			this.checked = false;
			Player.songs[songId].active=false;
			this.style.cursor="not-allowed";
			this.title="An error occurred with this song file";
			Player.songs[songId].playlistItem.classList.remove("songDisabled");
			Player.songs[songId].playlistItem.classList.add("songInError");
			Player.songs[songId].cover.src = Player.resources.errorCover.src;
		}else{
			Player.songs[songId].playlistItem.classList.add("songDisabled");
			this.title="Enable Song";
		}
		event.stopPropagation();
	});
	this.playlistItem.appendChild(this.cover);
	this.playlistItem.appendChild(this.songTitleTag);
	this.playlistItem.appendChild(this.checkBox);
	pEle.insertBefore(this.playlistItem,specialEle);
}
var Audio = {
	ctx:null,
	gainNode:null,
	analyser:null,
	state:{
		volume:0,
		source:-1,//-1 for none, 0 for music, 1 for microphone
	},
	mic:{
		source:null,//the aduio context source
		playing:false//tells if the microphone is active or not
	},
	music:{
		source:null//the html element that will play the music is linked here
		//playing is not needed as this will not be controlled by the audio object but the player object
	}

}

var Player = {
	songs:[],
	songOrder:[],
	songId:-1,//Identifies the song in the songs list currently playing, this list can only be added to, cannot change order or the ID system breaks down
	songNumber:-1,//Identifies the song in the songOrder list, which is a list of song ID's that correspond to the songs list.
	paused:true,
	playing:false,
	shuffle:false,
	volume:1,
	repeat:0,//0 for no repeats, 1 for repeat playlist, 2 for repeat song, 3 for play one song
	showPanel:true,
	controls:{//List of HTML elements for the controls on screen
		controlContainer:null,
		playButton:null,//play and pause
		timeLine:null,
		timeBack:null,//background of the line
		timeDot:null,
		fastforwardButton:null,
		rewindButton:null,
		backButton:null,
		skipButton:null,
		volumeDot:null,
		volumeLine:null,
		volumeBack:null,
		repeatButton:null,
		shuffleButton:null,
		optionButton:null
	},
	resources:{//List of images
		pause:new Image(256,256),
		play:new Image(256,256),
		repeatAll:new Image(256,256),
		repeatOne:new Image(256,256),
		repeatNone:new Image(256,256),
		shuffleOn:new Image(256,256),
		shuffleOff:new Image(256,256),
		fastforward:new Image(256,256),
		skip:new Image(256,256),
		back:new Image(256,256),
		rewind:new Image(256,256),
		dot:new Image(256,256),
		pauseDisabled:new Image(256,256),
		playDisabled:new Image(256,256),
		skipDisabled:new Image(256,256),
		backDisabled:new Image(256,256),
		rewindDisabled:new Image(256,256),
		fastforwardDisabled:new Image(256,256),
		defaultCover:new Image(256,256),
		errorCover:new Image(256,256),
		
	},
	loadResources:function(){
		this.resources.defaultCover.src = "resources/Disc.png";
        this.resources.errorCover.src = "resources/DiscBroken.png";
        },
	loadSongs:function(fileList){
		var fLength= fileList.length
		for(var sc = 0;sc<fLength;sc++){
			var newSong = new Song(fEle,sc);
			Player.songs.push(newSong);
			Player.songOrder.push(Player.songs[Player.songs.length-1]);//add to the song order
		}
	},
	nextSong:function(){
		switch(this.repeat){
			case 0:
				this.songNumber++;
				if(this.songNumber>=this.songOrder.length){//we have reached the end of the playlist
					this.songNumber = 0;
					return;
				}
				var suc = this.songOrder[this.songNumber].play();
				if(!suc){//the play failed
					Player.nextSong();
				}
			
				break;
			case 1:
				this.songNumber++;
				if(this.songNumber>=this.songOrder.length){
					this.songNumber = 0;
				}
				var suc = this.songOrder[this.songNumber].play();
				if(!suc){//the play failed
					Player.nextSong();
				}
			
				break;
			case 2:
				if(this.songOrder[this.songNumber].isDisabled())
					return;
				this.songOrder[this.songNumber].play();
			
				break;
			case 3:
				return;
				break;
			default:
				return;
			

		}
	},
	shuffleSongs:function(){
		var remainingSongs = Player.songOrder.slice(0);
		for(var i = 0;remainingSongs.length>0;i++){
			var numberOfSongs = remainingSongs.length;
			var songSelected = Math.floor(Math.random()*numberOfSongs);
			Player.songOrder[i]=remainingSongs[songSelected];
			pEle.insertBefore(Player.songOrder[i].playlistItem,specialEle);
			remainingSongs.splice(songSelected,1);
		}
	}

}

var fileElements=[];//a list of file elements that can hold the music files
function start(){
	if (hasStarted)
		return;
	hasStarted = true;
	Audio.ctx= new (window.AudioContext || window.webkitAudioContext)();
	Audio.music.source=Audio.ctx.createMediaElementSource(aEle);
	Audio.analyser=Audio.ctx.createAnalyser();
	Audio.gainNode = Audio.ctx.createGain();
	Audio.music.source.connect(Audio.analyser);
	Audio.analyser.connect(Audio.gainNode);
	Audio.gainNode.connect(Audio.ctx.destination);
	Audio.gainNode.gain.setValueAtTime(0, Audio.ctx.currentTime);//Mute audio so it doesn't create feedback
	Audio.analyser.fftSize=1024;
	fEle.addEventListener("change",function(){
		Audio.gainNode.gain.setValueAtTime(1,Audio.ctx.currentTime);
		if(Audio.mic.playing){
			Audio.mic.source.disconnect(Audio.analyser);
			Audio.mic.playing=false;
			}
		Player.loadSongs(fEle.files);
	})
	//fEle.addEventListener("change",function(){aSrc.src=URL.createObjectURL(fEle.files[0]);aEle.load();aEle.play();gainNode.gain.setValueAtTime(1,Audio.ctx.currentTime);if(mSource){mSource.disconnect(analyser)}})
	arr=new Uint8Array(Audio.analyser.frequencyBinCount);
	dataArray = new Uint8Array(Audio.analyser.frequencyBinCount);
	Player.loadResources();
	Graphics.start();
	update();
};
async function requestMic(){
if (navigator.mediaDevices.getUserMedia) {
	var allDevices = await navigator.mediaDevices.enumerateDevices();
  	let length = allDevices.length;
  	audioDevices=[];
  	while(iEle.firstChild){
	  	iEle.removeChild(iEle.firstChild);
 	 }
 	 for(let i = 0;i<length;i++){
		  if(allDevices[i].kind=="audioinput"){
			audioDevices.push(allDevices[i]);
			var newChild = document.createElement("option");
			newChild.innerHTML=allDevices[i].label;
			newChild.value = audioDevices.length-1;
			iEle.appendChild(newChild);
		  }
 	 }
		if(audioDevices.length>0){
		tryMic(0);
		}
  
} else {
  alert("***Could not obtain Microphone access***\nClick 'Load a File' to upload an audio file instead")
}

}
function tryMic(index){
	if(index>=0 && audioDevices.length){
		if(Audio.mic.playing){
			Audio.mic.source.disconnect(Audio.analyser);//disconnect if connected
			Audio.mic.source = null;
			Audio.mic.playing = false;
		}
		navigator.mediaDevices.getUserMedia({audio:{deviceId:audioDevices[index].deviceId}}).then( function(stream) {
		Audio.mic.source = Audio.ctx.createMediaStreamSource(stream);
		Audio.mic.source.connect(Audio.analyser);
		Audio.mic.playing = true;
		Audio.state.source = 1;
		Audio.gainNode.gain.setValueAtTime(0,Audio.ctx.currentTime);
		aEle.pause();
		console.log(stream);
		
  }).catch(errorCallback);
	}
}
function update(){
	requestAnimationFrame(update);
	Audio.analyser.getByteFrequencyData(arr);
									//op.innerHTML=Math.max.apply(null,arr);

	Audio.analyser.getByteTimeDomainData(dataArray);
	var width = window.innerWidth;
	var height = window.innerHeight;
	canvas.width = width;
	canvas.height = height;
	ct.clearRect(0,0,width,height);
	ct.strokeStyle="White";
	ct.fillStyle="rgba(0,255,0,0.5)";
	ct.beginPath();
	ct.moveTo(0,-arr[0]+(height/2));
	for(var i = 1;i<arr.length;i++){
		ct.lineTo(width/arr.length*i,-(arr[i]/255*height)+height);
	}
	ct.lineTo(width,height);
	ct.lineTo(0,height);
//	ct.fill();
//	ct.stroke();

	ct.beginPath();
	ct.moveTo(0,-dataArray[0]+height/2);
	for(var i = 1;i<dataArray.length;i++){
		ct.lineTo(width/dataArray.length*i,-(dataArray[i]/255*height)+height);
	}
	ct.lineTo(width,height);
	ct.lineTo(0,height);
ct.strokeStyle="rgba(255,0,0,0.5)"
					
//ct.stroke();
Graphics.render();
	
}
var errorCallback = function(e) {
	alert("***Could not obtain Microphone access***\nClick 'Load a File' to upload an audio file instead\n"+e)
    console.log(e);
  };
</script>

</body>
</html>
